###433. 岛屿的个数

给一个 01 矩阵，求不同的岛屿的个数。

0 代表海，1 代表岛，如果两个 1 相邻，那么这两个 1 属于同一个岛。我们只考虑上下左右为相邻。

#### 样例

**样例 1：**

```
输入：
[
  [1,1,0,0,0],
  [0,1,0,0,1],
  [0,0,0,1,1],
  [0,0,0,0,0],
  [0,0,0,0,1]
]
输出：
3
```

**样例 2：**

```
输入：
[
  [1,1]
]
输出：
1
```

#### 笔记

* 先for循环找到矩阵中第一个值为1的点，坐标记为```(i, j)```，将```(i, j)```put进队列q中。
* 当队列q不为空时，取出队首坐标存为temp，判断temp位置的上下左右邻接点的值，遇到值为1的点，则将该点坐标put进队列q中，并将矩阵中对应该点的值改为0。直到队列空，当前岛中的所有陆地搜寻完毕。
* 继续找下一个值为1的点，重复以上操作。

### 156. 合并区间

给出若干闭合区间，合并所有重叠的部分。

####样例

**样例1:**

```
输入: [(1,3)]
输出: [(1,3)]
```

**样例 2:**

```
输入:  [(1,3),(2,6),(8,10),(15,18)]
输出: [(1,6),(8,10),(15,18)]
```

####挑战

O(*n* log *n*) 的时间和 O(1) 的额外空间。

#### 笔记

**常规做法：**

* 首先对输入区间列表进行排序，排完序后区间左端点是有序的。

* 初始化一个list```List<Interval> merged```用于存放合并后的区间，将第一个区间存入```merged```，对剩余区间```i```判断```merged```数组中最后一个区间的end值```merged.get(len - 1).end```是否大于当前区间```i```的start值：
  * 如果成立，区间```i```和```merged```中的区间存在重合，比较```merged.get(len - 1).end```与```i.end```，将二者间较大值赋给```merged.get(len - 1).end```。
  * 如果不成立，区间```i```和```merged```中的区间不重合，因此直接将区间```i```存入```merged```列表。

**使用双指针达到O(*n* log *n*) 的时间和 O(*1*) 的额外空间的做法：**

* 先对输入区间列表进行默认排序，首先比较区间start值，如果区间start值相同则比较区间end值。
* 使用双指针，左边指针指向当前区间的开始，使用变量```currEnd```记录当前区间的最大值。
* 右指针向右移动：
  * 如果后续区间```i```的start值小于等于```currEnd```，则区间有重合，更新```currEnd```为```Math.max(currEnd, i.end)```。
  * 如果后续区间```i```的start值大于```currEnd```，则区间断开，将当前```currEnd```存入```merged```列表，左指针直接跳过已合并区间到区间```i```的start位置。

### 166. 链表倒数第n个节点

找到单链表倒数第n个节点，保证链表中节点的最少数量为n。

####样例

```
Example 1:
	Input: list = 3->2->1->5->null, n = 2
	Output: 1


Example 2:
	Input: list  = 1->2->3->null, n = 3
	Output: 1
```

#### 笔记

双指针，起始时刻指针1号和指针2号都指向head节点，指针1号走n步以后指针2号开始同步走，指针1号走到null节点时，指针2号所处位置与1号所处位置（链表尾部）距离为n，2号所指节点即为倒数第n个节点。