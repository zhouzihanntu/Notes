### 面向对象

####  成员变量与局部变量

* 成员变量：在方法体外，类体内声明的变量称为成员变量。
  * 实例变量（不以static修饰）
  * 类变量（以static修饰）
* 局部变量：在方法体内部声明的变量称为局部变量。
  * 形参（方法签名中定义的变量）
  * 方法局部变量（在方法内定义）
  * 代码块局部变量（在代码块内定义）

#### 方法的重载（Overload）

- 重载的概念
  - 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
- 重载的特点
  - 与返回值类型无关，只看参数列表，且参数列表必须不同。（参数个数或参数类型）。调用时根据方法参数列表的不同来区别。

#### 方法的可变参数的形参

* 用数组的方式来传递可变个数的参数

  ```public static void test(int a, String[] books);```

* 用java特有的**...**的方式来传递可变参数的个数，这种参数在使用时与数组的使用方式相同

  ```public static void test(int a, String...books);```

* 说明

  * 可变参数：方法参数部分指定类型的参数是可变多个
  * 声明方式：方法名（参数的类型名…参数名）
  * 可变参数方法的使用与方法参数部分使用数组是一致的
  * 如果一个方法有多个形参，可变的形参（...这种参数）需要放在所有形参声明的最后

#### 方法的参数传递

* 方法的形参：方法声明时的参数

* 方法的实参：方法调用时实际传给形参的参数值

* Java实参值如何传入方法：**值传递**。即将实际参数值的副本传入方法内，而参数本身不受影响。

  * 如果方法的形参是基本数据类型，那么实参（实际的数据）向形参传递参数时，就是直接传递值，把实参的值复制给形参。
  * 如果方法的形参是对象，那么实参（实际的对象）向形参传递参数时，也是把值给形参，这个值是实参在栈内存中的值，也就是饮用对象在堆内存中的地址。
  * 基本数据类型都是保存在栈内存中，引用对象在栈内存中保存的是引用对象的地址，那么方法的参数传递是传递值（变量在栈内存中的值）。


#### JDK中主要的包

* **java.lang** 包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。
* **java.net** 包含执行与网络相关的操作的类和接口。
* **java.io** 包含能提供多种输入/输出功能的类。
* **java.util** 包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。
* **java.text** 包含了一些java格式化相关的类。
* **java.sql** 包含了java进行JDBC数据库编程的相关类/接口。
* **java.awt** 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUI）。
* **java.applet** 包含applet运行所需的一些类。

#### 关键字this

* 作用
  * 在方法内部使用，即这个方法所属对象的引用；
  * 在构造器内部使用，表示该构造器正在初始化的对象。
* this表示当前对象，可以调用类的属性、方法和构造器
* 什么时候使用this关键字
  * 当在方法内需要用到调用该方法的对象时。
* 使用this调用属性、方法
  * 当形参与成员变量重名时，如果在方法内部需要使用成员变量，必须添加this来表明该变量是类成员；
  * 在任意方法内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性；
  * this可以作为一个类中，构造器相互调用的特殊格式。
    * 使用this()必须放在构造器的首行
    * 使用this调用本类中其他的构造器，保证至少有一个构造器是不用this的。（禁止出现构造器自己调用自己的情况）

#### JavaBean

* JavaBean是一种Java语言写成的可重用组件。
* JavaBean是指符合以下标准的Java类：
  * 类是公共的
  * 有一个无参的公共的构造器
  * 有属性，属性一般是私有的，且有对应的get、set方法
* 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。

****

### 面向对象之继承

多个类中存在相同属性和行为时，将这些内容抽取到单独的一个类中（父类），就无需再在多个类中定义这些属性和行为，只要继承父类即可。

#### 方法的重写(Override)

**定义：**在子类中可以根据需要对从父类中继承来的方法进行改造，也称方法的重置，覆盖。在程序执行时，子类的方法将覆盖父类的方法。

**要求：**

* 重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。
* 重写方法不能使用比被重写方法更严格的访问权限。
* 重写和被重写的方法必须同时为static的，或同时为非static的。
* 子类方法抛出的异常不能大于父类被重写方法的异常。

**关于访问权限修饰符**

* 如果子类和父类在同一个包下，对于父类的成员，修饰符只要不是private，子类就都可以使用。

* 如果子类和父类不在同一个包下，子类只能使用父类中protected和public修饰的成员。

#### 关键字super

在Java类中使用super来调用父类中的指定操作：

1. 访问父类中定义的属性
2. 调用父类中定义的成员方法
3. 在子类构造方法中调用父类的构造器

注：

* 尤其当子父类出现同名成员时，可以用super进行区分
* super的追溯不仅限于直接父类
* super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识

调用父类的构造器：

* 子类中的所有构造器默认都会访问父类中空参数的构造器。
* 在父类只有有参构造可以使用的时候，子类必须显式地构建一个构造来调用父类的有参构造，并且调用父类构造方法要写在第一行。
* 如果子类构造器中既未显式地调用父类或本类的构造器，父类中又没有无参的构造器，则编译出错。

#### 对象的实例化过程

#####简单类对象的实例化过程

以```Person p = new Person()```为例

1. 在方法区加载Person.class。
2. 在栈中申请空间，声明变量p。
3. 在堆内存中开辟空间，分配地址。
4. 在对象空间中，先对对象中的属性进行默认初始化，再对类成员变量进行显式初始化。
5. 将构造函数方法加载入栈，进行初始化。
6. 初始化完毕后，将堆内存中的地址值赋给引用变量，构造方法出栈。

##### 子类对象的实例化过程

以```Student stu = new Student()```为例，Student类继承了Person类。

1. 先加载Person.class，再加载Student.class。
2. 在栈中申请空间，声明变量stu。
3. 在堆内存中开辟空间，分配地址。
4. 在对象空间中，对对象中的属性（包括父类的属性）进行默认初始化。
5. 子类构造函数方法进栈。
6. 显式初始化父类的属性。
7. 父类构造方法进栈，执行完毕出栈。
8. 显式初始化子类的属性。
9. 初始化半完毕后，将堆内存中的地址值赋给引用变量，子类构造方法出栈。

****

###多态性

* 方法的重载(Overload)和重写(Overwrite)。
* 对象的多态性 ——可以直接应用在抽象类和接口上。
* Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。
  * 若编译时类型和运行时类型不一致，就出现多态（Polymorphism）。
* 对象的多态：在Java中，子类的对象可以替代父类的对象使用。
  * 一个变量只能有一种确定的数据类型
  * 一个引用类型变量可能指向（引用）多种不同类型的对象

```Person p = new Person();```

```Person e = new Student();```//Person类型的变量e，指向Student类型的对象。

子类可以看作是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型（upcasting）。

* 一个引用类型变量如果声明为父类的属性，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。

  ```java
  Student m = new Student();
  m.school = "pku";	//合法，Student类具有school成员变量
  Person e = new Student();
  e.school = "pku";	//非法，Person类没有school成员变量
  ```

  属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。

#### 虚拟方法调用

* 正常的方法调用

* ```
  Person p = new Person();
  p.getInfo();
  Student s = new Student();
  s.getInfo();
  ```

* 虚拟方法调用（多态情况下）

  ```Java
  Person e = new Student();
  e.getInfo();	//调用Student类的getInfo()方法
  ```

* 编译时类型和运行时类型

  编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。——动态绑定

#### 小结

* 前提：
  * 需要存在继承或者实现关系
  * 要有覆盖操作
* 成员方法：
  * 编译时：要查看引用变量所属的类中是否有所调用的方法。
  * 运行时：调用实际对象所属的类中的重写方法。
* 成员变量：
  * 不具有多态性，只看引用变量所属的类。
* 子类继承父类
  * 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。
  * 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。

****

###Object类

* Object类是所有Java类的根父类。
* 如果在类的声明中未使用extends关键字指明其父类，则默认父类为Object类。